"""Exploit planning and permission-aware execution helpers."""
from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import Dict, List, Mapping
import subprocess
import sys
import time


@dataclass(frozen=True)
class ExploitDefinition:
    exploit_id: str
    title: str
    description: str
    helper_script: str | None
    required_ports: tuple[int, ...] = ()
    required_factors: tuple[str, ...] = ()


EXPLOIT_DEFINITIONS: tuple[ExploitDefinition, ...] = (
    ExploitDefinition(
        exploit_id="enum_smb_shares",
        title="Enumerate SMB shares",
        description="Uses a helper script to call smbclient or smbmap to enumerate accessible shares.",
        helper_script="smb_enumeration.sh",
        required_ports=(445,),
    ),
    ExploitDefinition(
        exploit_id="probe_rdp_nla",
        title="Probe RDP Network Level Authentication",
        description="Leverages a helper to verify RDP configuration and screenshot banners.",
        helper_script="rdp_nla_probe.sh",
        required_ports=(3389,),
    ),
    ExploitDefinition(
        exploit_id="audit_snmp",
        title="Audit SNMP communities",
        description="Runs snmpwalk/snmp-check helpers to inspect SNMP strings.",
        helper_script="snmp_community_audit.sh",
        required_ports=(161,),
    ),
    ExploitDefinition(
        exploit_id="winrm_password_spray",
        title="WinRM password spray",
        description="Runs a PowerShell or crackmapexec helper to validate WinRM credentials.",
        helper_script="winrm_bruteforce_stub.sh",
        required_ports=(5985, 5986),
        required_factors=("winrm",),
    ),
)


@dataclass
class ExploitPlan:
    exploit_id: str
    title: str
    description: str
    helper_path: Path | None
    target: str
    rationale: str
    available: bool

    def as_dict(self) -> Dict[str, object]:
        return {
            "id": self.exploit_id,
            "title": self.title,
            "description": self.description,
            "helper_path": str(self.helper_path) if self.helper_path else None,
            "target": self.target,
            "rationale": self.rationale,
            "available": self.available,
        }


def build_exploit_plans(
    target: str,
    host_meta: Mapping[str, object],
    *,
    exploits_dir: Path,
) -> List[Dict[str, object]]:
    services = {int(port): name for port, name in host_meta.get("services", {}).items()}
    risk_factors = host_meta.get("risk_factors", {})

    plans: List[ExploitPlan] = []
    for definition in EXPLOIT_DEFINITIONS:
        if definition.required_ports and not any(port in services for port in definition.required_ports):
            continue
        if definition.required_factors and not all(risk_factors.get(factor) for factor in definition.required_factors):
            continue
        helper_path = None
        available = False
        if definition.helper_script:
            helper_path = exploits_dir / definition.helper_script
            available = helper_path.exists() and helper_path.is_file()
        rationale_parts = []
        if definition.required_ports:
            rationale_parts.append(
                f"observed port(s) {', '.join(str(p) for p in definition.required_ports if p in services)}"
            )
        if definition.required_factors:
            rationale_parts.append(
                f"risk factors: {', '.join(f for f in definition.required_factors if risk_factors.get(f))}"
            )
        plans.append(
            ExploitPlan(
                exploit_id=definition.exploit_id,
                title=definition.title,
                description=definition.description,
                helper_path=helper_path,
                target=target,
                rationale="; ".join(rationale_parts) or "Heuristic match",
                available=available,
            )
        )
    return [plan.as_dict() for plan in plans]


def execute_exploit_plan(
    plan: Mapping[str, object],
    *,
    auto_approve: bool,
    history: List[Dict[str, object]],
) -> str | None:
    helper_path = plan.get("helper_path")
    if not helper_path:
        _record(history, plan, status="not_available", output=None)
        return None
    helper = Path(str(helper_path))
    if not helper.exists():
        _record(history, plan, status="missing_helper", output=None)
        return None

    if not auto_approve:
        stdin = sys.stdin
        if not stdin or not hasattr(stdin, "isatty") or not stdin.isatty():
            _record(history, plan, status="no_tty", output=None)
            return None
        response = input(
            f"Execute exploit helper '{helper.name}' against {plan.get('target')}? [y/N]: "
        ).strip()
        if response.lower() not in {"y", "yes"}:
            _record(history, plan, status="denied", output=None)
            return None

    result = subprocess.run([str(helper)], capture_output=True, text=True)
    output = (result.stdout + result.stderr).strip()
    status = "completed" if result.returncode == 0 else "failed"
    _record(history, plan, status=status, output=output)
    return output


def _record(history: List[Dict[str, object]], plan: Mapping[str, object], *, status: str, output: str | None) -> None:
    entry = {
        "id": plan.get("id"),
        "target": plan.get("target"),
        "status": status,
        "timestamp": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
    }
    if output:
        entry["output"] = output
    history.append(entry)
